import { NextResponse } from 'next/server'
import fs from 'fs'
import path from 'path'

import mammoth from 'mammoth'
import pdfParse from 'pdf-parse'
import { prisma } from 'lib/prismaClient'
import { authMiddleware } from 'lib/authMiddleware'


import { NextRequest } from 'next/server'; // Add this import





function extractStructured(text: string) {
  const out: any = { name: null, email: null, phone: null, skills: [] }
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean)

  const emailRe = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g
  const emailMatch = text.match(emailRe)
  if (emailMatch) out.email = emailMatch[0]

  const phoneRe =
    /(?:\+\d{1,3}[\s-]?)?(?:\(\d{2,4}\)[\s-]?)?\d{2,4}[\s-]?\d{2,4}[\s-]?\d{2,4}/g
  const phoneMatch = text.match(phoneRe)
  if (phoneMatch) out.phone = phoneMatch[0]

  for (const l of lines.slice(0, 10)) {
    if (l.includes('@')) continue
    if (/[0-9]/.test(l)) continue
    if (l.length < 3 || l.length > 80) continue
    if (l.split(' ').length >= 2) {
      out.name = l
      break
    }
  }

  const SKILLS = [
    'javascript', 'typescript', 'react', 'next.js', 'nextjs', 'node', 'express', 'python', 'django', 'flask',
    'java', 'spring', 'c++', 'c#', '.net', 'go', 'ruby', 'rails', 'php', 'laravel',
    'sql', 'postgres', 'mysql', 'mongodb', 'redis', 'graphql', 'rest',
    'docker', 'kubernetes', 'aws', 'azure', 'gcp', 'terraform', 'ansible',
    'html', 'css', 'tailwind', 'sass', 'less', 'bootstrap', 'material-ui',
    'git', 'github', 'gitlab', 'bitbucket', 'jira', 'confluence',
    'agile', 'scrum', 'kanban', 'management', 'leadership', 'project management',
    'marketing', 'sales', 'seo', 'sem', 'content creation', 'social media',
    'data analysis', 'machine learning', 'artificial intelligence', 'deep learning',
    'ui/ux', 'figma', 'sketch', 'adobe xd', 'photoshop', 'illustrator',
    'communication', 'teamwork', 'problem-solving', 'critical thinking', 'adaptability',
    'customer service', 'financial analysis', 'budgeting', 'accounting', 'auditing',
    'cybersecurity', 'network security', 'devops', 'ci/cd', 'testing', 'qa', 'automation'
  ]
  const lower = text.toLowerCase()
  for (const s of SKILLS) {
    if (lower.includes(s)) out.skills.push(s)
  }
  out.skills = Array.from(new Set(out.skills))
  return out
}

function calculateScore(extractedSkills: string[], jobTitle: string, jobDescription: string): number {
  const jobText = (jobTitle + ' ' + jobDescription).toLowerCase()
  let score = 0
  for (const skill of extractedSkills) {
    if (jobText.includes(skill.toLowerCase())) {
      score += 1
    }
  }
  return score
}

export async function POST(req: NextRequest) { // Change Request to NextRequest{
  console.log('POST request received for /api/candidate/apply');
  
  try {
    const authResult = await authMiddleware(req)
    if ('status' in authResult) return authResult
    if ((authResult as any).type !== 'candidate') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const form = await req.formData()
    const jobId = form.get('jobId')?.toString() || ''
    const employerId = Number(form.get('employerId')?.toString() || '0')
    const email = form.get('email')?.toString() || null

    console.log('Received application data:', {
      jobId,
      employerId,
      email: email ? 'provided' : 'not provided'
    })

    // Validate required fields
    if (!jobId || !employerId) {
      console.error('Missing required fields:', { jobId, employerId })
      return NextResponse.json(
        { error: 'Missing required fields: jobId and employerId are required.' },
        { status: 400 }
      )
    }

    if (!email) {
      return NextResponse.json(
        { error: 'Email is required.' },
        { status: 400 }
      )
    }

    let resumePath: string | null = null
    let extracted: string = ''
    let buffer: Buffer | null = null

    const newResumeFile = form.get('resume') as File | null
    const existingResumePath = form.get('resumePath')?.toString() || null

    console.log('Resume options:', {
      hasNewResume: !!newResumeFile,
      hasExistingResume: !!existingResumePath
    })

    if (newResumeFile) {
      const filename = newResumeFile.name
      const arrayBuffer = await newResumeFile.arrayBuffer()
      const uint8Array = new Uint8Array(arrayBuffer)
      buffer = Buffer.from(uint8Array)

      const uploadsDir = path.join(process.cwd(), 'public', 'resumes')
      if (!fs.existsSync(uploadsDir)) {
        fs.mkdirSync(uploadsDir, { recursive: true })
      }
      const dest = path.join(uploadsDir, `${Date.now()}-${filename}`)
      fs.writeFileSync(dest, uint8Array)
      resumePath = dest.replace(process.cwd(), '')

      console.log('New resume saved to:', resumePath)

      if (filename.toLowerCase().endsWith('.docx')) {
        const result = await mammoth.extractRawText({ buffer })
        extracted = result.value || ''
      } else if (filename.toLowerCase().endsWith('.pdf')) {
        const result = await pdfParse(buffer)
        extracted = result.text || ''
      } else {
        return NextResponse.json(
          { error: 'Unsupported file type for new upload. Only DOCX and PDF are supported.' },
          { status: 400 }
        )
      }
    } else if (existingResumePath) {
      resumePath = existingResumePath
      const fullPath = path.join(process.cwd(), resumePath)
      
      if (!fs.existsSync(fullPath)) {
        console.error('Existing resume not found at:', fullPath)
        return NextResponse.json({ error: 'Existing resume not found.' }, { status: 404 })
      }

      console.log('Using existing resume at:', fullPath)

      // Read the content of the existing resume for extraction
      const fileExtension = path.extname(fullPath).toLowerCase()
      if (fileExtension === '.docx') {
        const fileBuffer = fs.readFileSync(fullPath)
        const result = await mammoth.extractRawText({ buffer: fileBuffer })
        extracted = result.value || ''
      } else if (fileExtension === '.pdf') {
        const fileBuffer = fs.readFileSync(fullPath)
        const result = await pdfParse(fileBuffer)
        extracted = result.text || ''
      } else {
        return NextResponse.json(
          { error: 'Unsupported file type for existing resume. Only DOCX and PDF are supported.' },
          { status: 400 }
        )
      }
    } else {
      return NextResponse.json({ error: 'No resume file or path provided.' }, { status: 400 })
    }

    if (!resumePath) {
      return NextResponse.json({ error: 'Resume path could not be determined.' }, { status: 500 })
    }

    console.log('Looking for job with ID:', jobId)
    const job = await prisma.job.findUnique({ where: { id: jobId } })
    if (!job) {
      console.error('Job not found with ID:', jobId)
      return NextResponse.json({ error: 'Job not found' }, { status: 404 })
    }

    console.log('Found job:', job.title)

    // Validate that the employerId matches the job's employer
    if (job.employerId !== employerId) {
      console.error('Employer ID mismatch:', {
        jobEmployerId: job.employerId,
        providedEmployerId: employerId
      })
      return NextResponse.json(
        { error: 'Invalid employer ID for this job.' },
        { status: 400 }
      )
    }

    // Check if candidate has already applied for this job
    const existingApplication = await prisma.application.findFirst({
      where: {
        candidateId: (authResult as any).user.id,
        jobId: jobId
      }
    })

    if (existingApplication) {
      return NextResponse.json(
        { error: 'You have already applied for this job.' },
        { status: 400 }
      )
    }

    const parsed = extractStructured(extracted)
    const score = calculateScore(parsed.skills, job.title, job.description)

    console.log('Extracted data:', {
      name: parsed.name,
      email: parsed.email,
      phone: parsed.phone,
      skills: parsed.skills,
      score
    })

    const app = await prisma.application.create({
      data: {
        jobId,
        employerId,
        resumePath: resumePath,
        extractedText: extracted,
        extractedName: parsed.name,
        extractedEmail: email || parsed.email,
        extractedPhone: parsed.phone,
        extractedSkills: parsed.skills.join(', '),
        score,
        candidateId: (authResult as any).user.id,
        status: 'PENDING',
      },
    })

    console.log('Application created with ID:', app.id)

    await prisma.notification.createMany({
      data: [
        {
          title: 'New application',
          body: `New application for job ${job.title}`,
          employerId,
          admin: false,
        },
        {
          title: 'New application',
          body: `New application for job ${job.title}`,
          admin: true,
        },
      ],
    })

    console.log('Notifications created')

    return NextResponse.json({ 
      success: true, 
      redirectUrl: `/jobs/${job.slug}/thank-you`,
      applicationId: app.id 
    })
  } catch (e) {
    console.error("Application submission error:", e)
    return NextResponse.json({ 
      error: e instanceof Error ? e.message : String(e) 
    }, { status: 500 })
  }
}

// Optional: Add GET method for testing if the route exists
export async function GET() {
  return NextResponse.json({ 
    message: 'API route is working',
    timestamp: new Date().toISOString()
  })
}